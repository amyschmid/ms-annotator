.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "TODO 3"
.TH TODO 3 "2016-11-05" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Use Sub::Quote"
.IX Header "Use Sub::Quote"
One attempt at this exists in the sub-quotify branch.
.PP
This has several parts.
.PP
First, type constraints should accept a single \f(CW\*(C`constraint\*(C'\fR parameter, rather
than both a constraint and an \f(CW\*(C`inline_generator\*(C'\fR. If the \f(CW\*(C`constraint\*(C'\fR is a
Sub::Quote sub, we can use that for inlining. This greatly simplified the \s-1API\s0.
.PP
The same should be done for the \f(CW\*(C`coercion\*(C'\fR & \f(CW\*(C`inline_generator\*(C'\fR parameters for
coercions.
.PP
Finally, the message_generator should be allow for a Sub::Quote sub and use
that for inlining if possible.
.PP
I'm not sure what the best \s-1API\s0 for the Sub::Quote subs is. Unlike with the
existing generators, Sub::Quote expects that parameters are always passed via
\&\f(CW@_\fR. This probably means that the sub you write should always look at
\&\f(CW$_[0]\fR, which is a little gross when inlining, as it means we have to jam
things into \f(CW@_\fR with something like:
.PP
.Vb 1
\&  local @_ = ($value);
.Ve
.PP
Note that this also means \fBnot\fR passing in the type constraint/coercion as
the first argument. In other words, these subs are no longer methods. This is
probably better for inlining anyway. Anything you wanted from the object
should be something you can inline anyway (I hope).
.PP
Note that parameterizable types \fIstill\fR need to provide a
parameterized_inline_generator sub (not a Sub::Quote). This sub shoudl
\&\fIreturn\fR a quoted sub based on the type parameter. Sub::Quote makes this
harder than it should be because it doesn't have a very nice \s-1API\s0. Oh well.
.SH "Union types and other set operations?"
.IX Header "Union types and other set operations?"
I'm not a huge fan of unions, they really confuse the notion of parent type,
for one thing. However, set operations on types are pretty useful.
.SH "Better integration with Moose"
.IX Header "Better integration with Moose"
Make Moose support inlining coercions and message generation with Specio objects.
.PP
Also, define a real \s-1API\s0 for type objects and have Moose just use duck typing
internally. However, this should \fInot\fR be the existing Moose \s-1TC\s0 \s-1API\s0, since
it's quite broken. In particular, the relationship between constraint &
coercion objects is backwards. A constraint should have many coercions, not
vice versa. Specio gets this right.
.SH "Support MooseX::Types barewords and string types with SpecioX modules"
.IX Header "Support MooseX::Types barewords and string types with SpecioX modules"
For barewords:
.PP
.Vb 1
\&  use SpecioX::Declare::Barewords => qw( Specio::Library::Builtins My::Library );
\&
\&  use Moose;
\&
\&  has foo => ( isa => Str );
.Ve
.PP
For string types:
.PP
.Vb 1
\&  use SpecioX::StringTypes => qw( Specio::Library::Builtins My::Library );
\&
\&  use Moose;
\&
\&  has foo => ( isa => \*(AqStr\*(Aq );
.Ve
.PP
Or something like that.
.PP
Internally these can both provide an attr trait and class trait that together
look up a registry for the class by name, something like:
.PP
.Vb 1
\&  use Specio::Registry qw( registry_for_package );
\&
\&  my $registry = registry_for_package($package);
.Ve
.PP
To parse things like \f(CW"ArrayRef[Str]"\fR we need to separate the type string
parsing into its module that can return a data structure like:
.PP
.Vb 4
\&  %parsed = (
\&      name      => \*(AqArrayRef\*(Aq,
\&      parameter => \*(AqStr\*(Aq,
\&  );
.Ve
.PP
Then we can look these up with:
.PP
.Vb 1
\&  my $type = t( $parsed{name}, of => t( $parsed{parameter} ) );
.Ve
